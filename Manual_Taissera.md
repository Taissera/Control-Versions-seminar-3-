# Инструкция по работе с git 

## Подготовка 

1. **Регистрация на GitHub**. 
GitHub ­ это сервис для хранения репозиториев.  Репозиторий научного проекта будет находиться именно там, поэтому если у вас еще нет аккаунта на GitHub, вам необходимо пройти стандартную процедуру регистрации.

2. **Установить git** с официального сайта по инструкции: http://git­scm.com/downloads

3. Все команды git выполняются в **терминале** (командной строке).

4. **Настройка git**. Нам будет достаточно только задать имя и email командами:
    * _git config ­­global user.name "Ivan Ivanov"_
    * _git config ­­global user.email example@example.com_

## Базовые операции

* **Создание локальной копии главного репозитория**.

Давайте создадим в каталоге репозитория текстовый файл **_manual.md_**, содержащий строку текста **_"Some text"_**. Однако то, что файл появился в каталоге репозитория не означает, что git его уже отслеживает ­ нужно указать это явно командой: 

**_git add manual.md_**

Теперь наш файл находится под наблюдением git. Давайте сохраним изменения в
репозитории и сделаем первый коммит:

**_git commit -­m "Комментарий к коммиту на Eng языке"_**

**-­m** позволяет задать описание коммита. Описание обязательно, иначе коммит не будет выполнен.

* **Сохранение изменений файлов**. 

Добавим в файл **_manual.md_** еще одну строчку **_"Some more text"_** (не забудьте сохранить файл!). И снова закоммитим изменения. Однако если мы воспользуемся известной нам командой:

**_git commit -­m "more text added to first.txt"_**

Чтобы меньше запоминать, вам будет достаточно для всех коммитов пользоваться
командой именно такого вида.

**-­a** позволяет учесть изменения только в файлах, уже
находящихся под наблюдением git. А новые файлы перед коммитом необходимо
предварительно явно добавить командой **_git add_**.

**_git commit -a -­m "more text added to first.txt"_**

* **Проверить текущий статус репозитария** 

Используйте команду **_git status_**

![Status](.\Status.png)

* **Просмотреть историю проекта**
Используйте команду **_git log_**

![Status](.\Log.png)

* **Переход между коммитами**

Используйте команду **_git checkout номер коммита_**
Номера коммитов можно посмотреть посредством команды **_git log_**

* **Вернуться к актуальному состоянию и продолжить работу**

Используйте команду **_git checkout master_**

* **Просмотреть разницу между текущим файлом и закоммиченным файлом**

Используйте команду **_git diff_**

## Краткое содержание по работе с Git и языком Markdown

* Основные команды Git

✦ git init – инициализация локального репозитория

✦ git status – получить информацию от git о его текущем состоянии

✦ git add – добавить файл или файлы к следующему коммиту

✦ git commit -m “message” – создание коммита.

✦ git log – вывод на экран истории всех коммитов с их хеш-кодами

✦ git checkout – переход от одного коммита к другому

✦ git checkout master – вернуться к актуальному состоянию и продолжить работу

✦ git diff – увидеть разницу между текущим файлом и закоммиченным файлом


* Синтаксис языка Markdown

Справочник по Markdown от Microsoft:
https://docs.microsoft.com/ru-ru/contribute/markdown-reference

✦ # Заголовок – выделение заголовков. Количество символов “#” задаёт уровень заголовка (поддерживается 6 уровней).

✦ = или - – подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки 
первого (“=”) и второго (“-”) уровней.

✦ ** Полужирное начертание** или __ Полужирное начертание__

✦ *Курсивное начертание* или _Курсивное начертание_

✦ ***Полужирное курсивное начертание***

✦ ~~Зачёркнутый текст~~

✦ * Строка – ненумерованные списки, символ “*” в начале строки

✦ 1, 2, 3 … – нумерованные списки

## Дополнительные источники по работе с Git и языком Markdown

* [Git для новичков (часть 1)](https://habr.com/ru/post/541258/)
* [Git для новичков (часть 2)](https://habr.com/ru/post/542616/)
* [Git для начинающих](https://ruseller.com/lessons.php?rub=28&id=2035)
* [Справочные материалы по Markdown](https://learn.microsoft.com/ru-ru/contribute/markdown-reference)
* [Использование ссылок в документации](https://learn.microsoft.com/ru-ru/contribute/how-to-write-links)

## Ветки

### 1. *Работа с Ветками*

Ветка в Git это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита. Визуально это можно представить вот так.

![Status](.\vetki.png)

Сделать новую ветку и переключиться на нее можно выполнив команду

*__git checkout –b имя_новой_ветки__*

Просто сделать ветку, не переключаясь на нее можно командой

*__git branch имя_новой_ветки__*

переключиться на ветку

*__git checkout –b имя_ветки__*

*Важно понимать, что ветка берет свое начало не от ветки, а от последнего коммита который находиться в той ветке, в которой вы находились*

Ветка обычно заканчивается специальным merge коммитом, который говорит, что ветку нужно объединить с какой-то другой веткой. В merge коммите содержатся две ссылки на два коммита которые объединяются в одну ветку.

![Status](.\merge_commit.png)

После того, как ветка объединяется с другой веткой, все коммиты сделанные в ней, попадают в ветку с которой она была объединена. Так же важно понимать, что merge это не двунаправленная операция. Если смержить ветку задачи в мастер ветку, то в мастер ветке появится код, который находился в ветке задачи, а в ветке задачи не появиться новый код из мастер ветки. Если нужно что бы это произошло, нужно смержить мастер ветку в ветку задачи.
Что бы смержить одну ветку в другую нужно вначале переключиться на ту ветку, в которую вы хотите смержить.

Чтобы смержить одну ветку в другую нужно вначале переключиться на ту ветку, в которую вы хотите смержить

*__git checkout имя_ветки__*

Затем выполнить команду

*__git merge имя_ветки_которую_надо_смержить__*

### 2. *Конфликты при слиянии (merge) веток*

Конфликты возникают при мердже веток если в этих ветках одна и та же строка кода была изменена по-разному. Тогда получается, что Git не может сам решить какое из изменений нужно применить и он предлагает вручную решить эту ситуацию. Это замедляет работу с кодом в проекте. Избежать этого можно разными методами. Например, можно распределять задачи так, чтобы связанные задачи не выполнялись одновременно различными программистами.
Другой способ избежать этого, это договориться о каком-то конкретном стиле кода. Тогда программисты не будут менять форматирование кода и вероятность того, что они изменят одну и ту же строчку станет ниже.

Еще один хороший совет, который поможет вам избежать конфликтов при работе в команде, это вносить минимум изменений в код при решении задач. Чем меньше строчек вы поменяли, тем меньше вероятность что вы измените ту же самую строку что и другой программист в другой задаче.

После того, как в мастер ветке достигается состояние, которое можно считать стабильным оно отмечается тегом с версией этого состояния. Это и есть то что называют версией программы.
Делается это вот так

*__git tag -a v1.0__*

Теги удобны еще и тем, что можно легко переключиться на то состояние кода которое отмечено тегом. Делается это с помощью все той же команды

*__git checkout имя_тега__*

### 3. *Удаление веток*

Большинство веток в ваших репозиториях, скорее всего, будут короткоживущими: создали ветку, протестировали новую функцию, *слили ветку с основной* и удалили ее.

Как и всегда, когда речь доходит до удаления чего-либо, нужно быть очень *осторожными*. Когда вы удаляете ветку, все изменения, которые не были добавлены в коммит, будут утеряны. 

Итак, для удаления ветки используйте команды

* *__git branch -d имя_ветки__*

-d (delete) c этим ключем команда удалит вашу ветку. Ветка будет удалена только в том случае, если она полностью слита с одной из других веток. В противном случае, Git выдаст предупреждение, о том, что в ветке есть неслитые изменения, и не даст ее удалить.

* *__git branch -D имя_ветки__*

-D (Delete) этот ключ нужен, если вы хотите удалить ветку, игнорируя предупреждения Git. В отличие от -d, этот ключ удалит ветку в любом случае, даже если в ней есть изменения, которые вы можете потерять.

Большинство веток в ваших репозиториях, скорее всего, будут короткоживущими: создали ветку, протестировали новую функцию, *слили ветку с основной* и удалили ее.

Как и всегда, когда речь доходит до удаления чего-либо, нужно быть очень *осторожными*. Когда вы удаляете ветку, все изменения, которые не были добавлены в коммит, будут утеряны. 

Если вам нужно получить список определенного множества веток, то можно воспользоваться ключами. Одними из самых распространенных будут:

-r — при использовании этого ключа мы получим список удаленных веток,
-a — используя этот параметр, в выводе будут удаленные и локальные ветки.

В процессе разработки могут возникнуть ситуации, когда необходимо по-другому называть уже созданную ветку. Это может быть связано с разными причинами (например, разрабатываемый в данной версии функционал не соответствует названию). 

Чтобы переименовать ветку используйте команду

*__git branch -m новое_имя_ветки__*

Однако, здесь нужно быть аккуратными, чтобы не перегрузить проект ненужными ветками. Если запушить переименованную ветку, то на сервере появится ветка с новым именем, но и ветка со старым названием тоже останется. 

Чтобы избежать такой проблемы, *необходимо удалить ветку локально и на сервере*.

### Подробнее о работе с Ветками можно ознакомиться на ресурсах

* [Git на практике](https://habr.com/ru/post/342116/)
* [Работа с Git](https://smartiqa.ru/courses/git)
* [Работа с ветками в Git (git branch)](https://selectel.ru/blog/tutorials/how-to-work-with-branches-in-git-git-branch/)